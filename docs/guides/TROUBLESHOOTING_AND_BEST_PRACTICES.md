# 開発トラブルシューティングと再発防止策

## 1. はじめに

このドキュメントは、開発過程で発生した重大な問題とその解決策を記録し、同様の問題の再発を防止するためのガイドラインを定めるものです。

## 2. ケーススタディ

### ケース1: Qdrantデータベースのローカル接続問題

#### 発生した問題

ローカル環境で`make run`を実行した際、GoアプリケーションがDockerで起動しているQdrantコンテナに接続できず、`name resolver error: produced zero addresses`というエラーが頻発し、サーバーが起動しなかった。

#### 誤った仮説と遠回り

- **仮説1:** `localhost`の名前解決の問題。
    - **対策:** 接続先を`127.0.0.1`に変更したが、解決せず。
- **仮説2:** 開発コンテナのネットワーク問題。
    - **対策:** ユーザーが開発コンテナ内で作業していると誤解し、接続先をDockerのコンテナ名(`qdrant_db`)に変更したが、ユーザーはホストマシンで作業していたため、これも間違いだった。

#### 根本原因

**Qdrant Cloud対応のために追加したコードが、既存のローカル接続機能を破壊していたこと。**

以前、ローカル接続に成功していた時点のコードは、暗号化（TLS）を完全に無効にする、非常にシンプルな接続方式でした。

```go
// 成功していた接続オプション
grpc.WithTransportCredentials(insecure.NewCredentials())
```

その後、Qdrant Cloud（要TLS）とローカル（非TLS）の両方に対応させようとして、以下のような条件分岐を追加しました。この`else`節で使った`credentials.NewTLS(&tls.Config{InsecureSkipVerify: true})`が、非TLSサーバーであるローカルQdrantへの接続を妨げていました。

```go
// 問題のあったコード
if strings.HasSuffix(qdrantURL, ":443") {
    // Qdrant Cloud用のTLS接続処理
} else {
    // ローカル接続用の処理（ここが間違っていた）
    creds := credentials.NewTLS(&tls.Config{InsecureSkipVerify: true}) // これが間違い
    dialOpts = append(dialOpts, grpc.WithTransportCredentials(creds))
}
```

#### 最終的な解決策

`vector_store_service.go`から、後から追加した複雑な条件分岐をすべて削除し、**過去に成功が確認されている、ローカル接続専用のシンプルなコード**に完全に戻すことで解決しました。

### ケース2: Azure OpenAIプロキシ設定問題

#### 発生した問題

Azure OpenAI APIを呼び出す際、指定されたプロキシURL経由での接続ができなかった。

#### 根本原因

Goの標準HTTPクライアントの`Proxy`フィールドは、一般的なプロキシサーバー（CONNECTメソッド等）を設定するためのものであり、今回の要件（プロキシURLをAPIエンドポイントそのものとして扱う）とは異なっていたため。

#### 最終的な解決策

`http.Transport`の`Proxy`フィールドは設定せず、Azure OpenAIクライアントのコンストラクタに渡す**エンドポイントURLの文字列自体を、プロキシのURLに差し替える**ことで解決しました。

## 3. 再発防止策と今後の開発ガイドライン

### 原則1: 変更は小さく、検証は頻繁に

一つの機能追加（例: Qdrant Cloud対応）が、既存の正常な機能（例: ローカル接続）を破壊しないよう、変更は一度に一つずつ行い、その都度`make run`や関連テストで動作確認を行う。

### 原則2: 環境ごとの設定はコードから分離する

接続先URLなどの環境に依存する値は、コードに直接書き込む（ハードコードする）のではなく、**環境変数**と**設定ファイル（`configs/config.go`）**を経由して注入する。

- **今後の課題:** 現在のコードは、この原則に反し、ローカル接続専用（`127.0.0.1:6334`がハードコードされている）状態にある。次のステップとして、再度Qdrant Cloudに対応させる際は、この原則を徹底する。

### 原則3: 「壊してはいけないロジック」の保護

安定して動作している基盤となるコード（例: 今回復元したシンプルなローカル接続コード）には、安易に変更を加えない。変更を加える際は、元のコードをコメントアウトして残すか、Gitのブランチで作業するなど、いつでも元に戻せる状態を確保する。

特に、**環境の差異を吸収するための条件分岐（`if/else`）**を追加する際は、すべての分岐パスがそれぞれの環境でテストされることを保証する。

### 原則4: ユーザーの環境を正しく理解する

開発コンテナ内で作業しているのか、ホストマシンで作業しているのかなど、コマンドの実行環境を最初に正確に把握することが、トラブルシューティングの精度を大きく左右する。不明な場合は、推測せずに質問する。

## 4. 開発・修正における行動原則 (自己戒律)

度重なる修正ミスを防ぎ、お客様からの信頼を回復するため、私自身は以下の行動原則を遵守します。

### 原則5: リファクタリング時の`write_file`の原則禁止

既存のGoのソースコードを修正する目的で、`write_file`を使いファイル全体を上書きする行為を原則として禁止します。これは、思考プロセスの中で既存のコードの文脈を省略・忘却し、不完全なファイルを生成してしまうミスを繰り返したためです。例外は、`git restore`でも復元不可能なほどファイルが破損し、かつ修正内容が完全に確定している場合に限定します。

### 原則6: `replace`の安全な利用（最小範囲、事前確認、分割）

`replace`ツールは強力ですが、誤用するとコードを破壊します。今後の利用は以下のルールを徹底します。
- **変更範囲の最小化**: 数行程度の、変更範囲が明確で、かつファイル内で一意に特定できるコードブロックにのみ使用します。
- **事前確認の義務化**: `replace`実行直前に、必ず`read_file`で対象ファイルの最新の内容を確認し、正確な`old_string`を特定します。推測で`old_string`を記述しません。
- **複数ステップへの分割**: 複数の関数や、ファイルの離れた箇所にまたがる変更は、一度に行わず、「1つの`replace` = 1つの論理的な変更」として分割し、その都度ユーザーに確認を求めます。

### 原則7: 段階的修正と頻繁な検証の徹底

ビルドエラーの修正やリファクタリングは、一度に一つの論理的な変更のみを行い、その都度`make run`などでビルドが通ることを確認します。「まずこれを修正して、エラーがどう変わるか見てみましょう」という対話的なアプローチを基本戦略とします。